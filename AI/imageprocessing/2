//Jacob Holtom
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define W 640
#define H 480
#define for_x for (int x = 0; x < W; x++)
#define for_y for (int y = 0; y < H; y++)
#define for_yx for_y for_x
int rgb[H][W][3];
typedef struct sphere {
    int r,g,b;
    float x,y,z,rad;
} sphere;
typedef struct light {
    float x,y,z;
} light;
void pixel(int rgb[H][W][3], int x, int y, int r, int g, int b)
{
    rgb[y][x][0] = r; // red
    rgb[y][x][1] = g; // green
    rgb[y][x][2] = b; // blue
}
double dto(double sx, double sy, double sz, double end_x, double eny, double enz, double intersect[3],sphere s) {
   // Vector from start to end point
   double rx = end_x - sx;
   double ry = eny - sy;
   double rz = enz - sz;

   // Magnitude of vector
   double magn_ray = sqrt(rx*rx+ry*ry+rz*rz);

   // Make it a unit vector
   rx = rx / magn_ray;
   ry = ry / magn_ray;
   rz = rz / magn_ray;

   // Ignore this, it's for the next part
   double coefficient_1 = sx - s.x
   double coefficient_2 = sy - s.y
   double coefficient_3 = sz - s.z

   // Create a quadratic
   double a = (rx*rx)+(ry*ry)+(rz*rz);
   double b = 2*((coefficient_1*rx)+(coefficient_2*ry)+(coefficient_3*rz));
   double c = (coefficient_1*coefficient_1)+(coefficient_2*coefficient_2)+(coefficient_3*coefficient_3)-(spheres[sphere][3]*spheres[sphere][3]);
   // Find the discriminant
   double discrim = ((b*b)-4*a*c);

   if(discrim < 0) {
      return -1;
   }
   else {
      double T = ((b*-1)-sqrt((b*b)-4*a*c))/(2*a);

      intersect[0] = fudge(((T * rx) + sx), spheres[sphere][0]);
      intersect[1] = fudge(((T * ry) + sy), spheres[sphere][1]);
      intersect[2] = fudge(((T * rz) + sz), spheres[sphere][2]);
      
      return T;
   }
}
void write(int rgb[H][W][3])
{
    int y , x ;
    FILE* fout ;
    fout = fopen( "output.ppm" , "w" ) ;
    fprintf( fout , "P3\n" ) ;
    fprintf( fout , "%d %d\n" , W , H ) ;
    fprintf( fout , "255\n" ) ;
    for( y = 0 ; y < H ; y++ )
    {
        for( x = 0 ; x < W ; x++)
        {
            fprintf( fout , "%d %d %d\n" , rgb[y][x][0] , rgb[y][x][1] , rgb[y][x][2] ) ;
        }
    }
    close( fout ) ;
}
void tracer(int rgb[H][W][3]){
    sphere s0,s1,s2;
    light r0;
    //Sphere 0
    s0.x = 0.500000; 
    s0.y = 0.500000;
    s0.z = 0.166667;
    s0.rad = 0.166667;
    s0.r = 0;
    s0.g = 0;
    s0.b = 255;
    //Sphere 1
    s1.x = 0.833333; 
    s1.y = 0.500000;
    s1.z = 0.500000;
    s1.rad = 0.166667;
    s1.r = 0;
    s1.g = 255;
    s1.b = 0;
    //Sphere 2
    s2.x = 0.333333;
    s2.y = 0.666667;
    s2.z = 0.666667;
    s2.rad = 0.333333;
    s2.r = 255;
    s2.g = 0;
    s2.b = 0;
    //Light
    r0.x = 0.000000; 
    r0.y = 1.000000;
    r0.z = -0.500000;
    //Eye
    double ex = 0.500000;
    double ey = 0.500000;
    double ez = -1.000000;
    // Screen
    double sz = 0.000000;
    // Floor
    double fy = 0.333333;
    int current = 1;
    double min_val = 999;
    int min_index = -1;
    double px, py, pz, T;
    double intersect[3];
    int y, x,q,k;
    for_yx {
        for(q=0; q<3; q++) {
            current = q;
            py = 1-(y*1.0/H);
            px = (x*1.0/W);
            pz = sz;

            T = distance_to_object(ex, ey, ez, px, py, pz, spheres, q+1, intersect);

            // Pick which ovject is closest
            if (T > 0 && T < min_val) {
                min_index = current;
                min_val = T;
            }
        }
    }
}
void black(int rgb[H][W][3]){
    int y, x;
    for_yx {
        pixel(rgb,y,x,0,0,0);
    }
}
int main(void){
    black(rgb);
    tracer(rgb);
    write(rgb);
    return 0;
}
